/* tslint:disable */
/* eslint-disable */
/**
 * Dinero API
 * Welcome to our endpoint documentation. Please try to carefully read our general documentation found on <a href=\"https://developer.dinero.dk/\">developer.dinero.dk</a> for information regarding the authorization proces, status and errorcodes, FAQ, Postman tutorial etc. <br><br>Once authorized, you simply add \'Authorization: Bearer <access-token>\' to the header of your requests. On the page below, you\'ll find all our endpoints documented as well as possible, but if you have any questions regarding an endpoint, or an error in the description, please contact us on <a href=\"mailto:api@dinero.dk\">api@dinero.dk.</a> 
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { ApiMailoutModel } from '../model';
// @ts-ignore
import type { BookModel } from '../model';
// @ts-ignore
import type { CreatedPaymentResponse } from '../model';
// @ts-ignore
import type { CreatedResponseModel } from '../model';
// @ts-ignore
import type { DeletedPaymentResponse } from '../model';
// @ts-ignore
import type { EInvoiceSendModel } from '../model';
// @ts-ignore
import type { EanSendModelV2 } from '../model';
// @ts-ignore
import type { EmailSentModel } from '../model';
// @ts-ignore
import type { InvoiceCreateFetchModel } from '../model';
// @ts-ignore
import type { InvoiceCreateModel } from '../model';
// @ts-ignore
import type { InvoiceFetchReadModel } from '../model';
// @ts-ignore
import type { InvoicePaymentsModel } from '../model';
// @ts-ignore
import type { InvoiceReadModel } from '../model';
// @ts-ignore
import type { InvoiceTemplateModel } from '../model';
// @ts-ignore
import type { InvoiceUpdateModel } from '../model';
// @ts-ignore
import type { MailoutTemplateReadModel } from '../model';
// @ts-ignore
import type { MailoutTemplateReadModelV2 } from '../model';
// @ts-ignore
import type { PaymentCreateModel } from '../model';
// @ts-ignore
import type { SalesVoucherReadListModelDineroCollection } from '../model';
// @ts-ignore
import type { TimestampObject } from '../model';
// @ts-ignore
import type { UpdatedResponseModel } from '../model';
// @ts-ignore
import type { VoucherMailoutReadModel } from '../model';
/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update an existing invoice. The invoice cannot be updated if booked. Note that the put request per rest standard will update the entire invoice and not only the fields you send.
         * @summary Update invoice
         * @param {string} guid Unique identifier for the invoice information
         * @param {string} organizationId 
         * @param {InvoiceUpdateModel} [invoiceUpdateModel] Content of the invoice to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v12OrganizationIdInvoicesGuidPut: async (guid: string, organizationId: string, invoiceUpdateModel?: InvoiceUpdateModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('v12OrganizationIdInvoicesGuidPut', 'guid', guid)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v12OrganizationIdInvoicesGuidPut', 'organizationId', organizationId)
            const localVarPath = `/v1.2/{organizationId}/invoices/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceUpdateModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a invoice to get total, line sums and payment date calculations.
         * @summary Get invoice totals
         * @param {string} organizationId 
         * @param {InvoiceCreateFetchModel} [invoiceCreateFetchModel] Model of the invoice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesFetchPost: async (organizationId: string, invoiceCreateFetchModel?: InvoiceCreateFetchModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesFetchPost', 'organizationId', organizationId)
            const localVarPath = `/v1/{organizationId}/invoices/fetch`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceCreateFetchModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of invoices for the organization.  This can return quite a long list of invoices, consider using the changesSince filter to only return invoices that have been changed since the last time you fetched the list.  Also note that deleted invoices will not be returned on this list per default.
         * @summary List invoices
         * @param {string} organizationId 
         * @param {string} [startDate] Start date in format \&#39;YYYY-MM-DD\&#39; example \&#39;2015-01-01\&#39;. If you define a start date, you also need to define an end date. Note that drafts are not affected by this filter.
         * @param {string} [endDate] End date in format \&#39;YYYY-MM-DD\&#39; example \&#39;2015-01-01\&#39;. If you define an end date, you also need to define a start date.  Note that drafts are not affected by this filter.
         * @param {string} [fields] A comma separated list of fields to include in the response.              Possible values are:              Number, Guid, ExternalReference, ContactName, ContactGuid, Date, PaymentDate, Description, Currency, Status, MailOutStatus, LatestMailOutType, TotalExclVatInDkk, TotalInclVatInDkk              TotalExclVat, TotalInclVat, CreatedAt, UpdatedAt and DeletedAt.              If null, defaults to Guid,ContactName,Date,Description.              Notice that it\&#39;s not case sensitive, the property name will be returned the way you request it.
         * @param {string} [freeTextSearch] A free text search performed on Number, ContactName, Description and TotalInclTax
         * @param {string} [statusFilter] Filter on Status. You can choose Draft, Booked, Paid, OverPaid or Overdue. You can add multible filters example: \&#39;Paid,OverPaid,Overdue\&#39;. If left empty no filter is applied.
         * @param {string} [queryFilter] Filtering can be applied to following fields:              ExternalReference, ContactGuid, Description. See API documentation for filtering format. If left empty no filtering is applied.
         * @param {string} [changesSince] [Generic Filter Option] Only return invoices that was created, deleted or updated at or after given time.              If left empty, this filter will not be applied, and invoices will be returned regardless of change history.              The time must be UTC and in the format \&#39;YYYY-MM-DDTHH:mm:ssZ\&#39; example: \&#39;2015-08-18T06:36:22Z\&#39;.
         * @param {boolean} [deletedOnly] [Generic Filter Option] Only select deleted invoices. If left empty, will defaults to false.
         * @param {number} [page] The 0-based page number
         * @param {number} [pageSize] The maximum number of items to include in a page. Maximum 1000.
         * @param {string} [sort] A comma separated list of fields to sort on. Possible values are: VoucherNumber, VoucherDate, Status and Contact.
         * @param {string} [sortOrder] Sort order. Valid values are ascending and descending. Field Status is always sorted in the order Draft, Overdue, Booked, OverPaid and Paid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGet: async (organizationId: string, startDate?: string, endDate?: string, fields?: string, freeTextSearch?: string, statusFilter?: string, queryFilter?: string, changesSince?: string, deletedOnly?: boolean, page?: number, pageSize?: number, sort?: string, sortOrder?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGet', 'organizationId', organizationId)
            const localVarPath = `/v1/{organizationId}/invoices`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (freeTextSearch !== undefined) {
                localVarQueryParameter['freeTextSearch'] = freeTextSearch;
            }

            if (statusFilter !== undefined) {
                localVarQueryParameter['statusFilter'] = statusFilter;
            }

            if (queryFilter !== undefined) {
                localVarQueryParameter['queryFilter'] = queryFilter;
            }

            if (changesSince !== undefined) {
                localVarQueryParameter['changesSince'] = changesSince;
            }

            if (deletedOnly !== undefined) {
                localVarQueryParameter['deletedOnly'] = deletedOnly;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Book invoice. Booking means actually posting the invoice to the accounts. A booked invoice can also be send via email, sms or as an e-invoice.
         * @summary Book invoice
         * @param {string} guid Guid of the invoice to book
         * @param {string} organizationId 
         * @param {BookModel} [bookModel] Data used for the booking transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidBookPost: async (guid: string, organizationId: string, bookModel?: BookModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidBookPost', 'guid', guid)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidBookPost', 'organizationId', organizationId)
            const localVarPath = `/v1/{organizationId}/invoices/{guid}/book`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete invoice. The invoice should not be deleted if booked. In that case a creditnote would be the correct way to cancel the invoice.
         * @summary Delete invoice
         * @param {string} guid Unique identifier for the invoice
         * @param {string} organizationId 
         * @param {TimestampObject} [timestampObject] optional timestamp to verify version before deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidDelete: async (guid: string, organizationId: string, timestampObject?: TimestampObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidDelete', 'guid', guid)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidDelete', 'organizationId', organizationId)
            const localVarPath = `/v1/{organizationId}/invoices/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timestampObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an email with link to a public version of the invoice where it can be printed or downloaded as a pdf. The invoice must be booked.
         * @summary Send invoice email
         * @param {string} guid Guid of the invoice to send
         * @param {string} organizationId 
         * @param {ApiMailoutModel} [apiMailoutModel] Model of the email to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidEmailPost: async (guid: string, organizationId: string, apiMailoutModel?: ApiMailoutModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidEmailPost', 'guid', guid)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidEmailPost', 'organizationId', organizationId)
            const localVarPath = `/v1/{organizationId}/invoices/{guid}/email`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiMailoutModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a pre reminder email with link to a public version of the invoice where it can be printed or downloaded as a pdf.  The invoice needs to be overdue to send the reminder.  A pre-reminder is a mail reminding the customer, that the invoice is overdue. This will not cause a reminder to be created in Dinero, this is only a mailout.
         * @summary Send invoice prereminder
         * @param {string} guid Guid of the invoice to send
         * @param {string} organizationId 
         * @param {ApiMailoutModel} [apiMailoutModel] Model of the email to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidEmailPreReminderPost: async (guid: string, organizationId: string, apiMailoutModel?: ApiMailoutModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidEmailPreReminderPost', 'guid', guid)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidEmailPreReminderPost', 'organizationId', organizationId)
            const localVarPath = `/v1/{organizationId}/invoices/{guid}/email/pre-reminder`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiMailoutModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the email template for a pre-reminder. This can be used to preview what will be sent out on the email. These standards can be overwritten during the sending phase.
         * @summary Get pre-reminder template
         * @param {string} guid Guid of the invoice to send
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidEmailPreReminderTemplateGet: async (guid: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidEmailPreReminderTemplateGet', 'guid', guid)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidEmailPreReminderTemplateGet', 'organizationId', organizationId)
            const localVarPath = `/v1/{organizationId}/invoices/{guid}/email/pre-reminder/template`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate and saves a creditnote draft of a given booked invoice. If you need to create a standalone creditnote or a partial creditnote, please look at the creditnote category further down the documentation. Remeber to also book and send the creditnote to fully automate the booking process.
         * @summary Create credit note from invoice
         * @param {string} guid Guid of the invoice
         * @param {string} organizationId 
         * @param {TimestampObject} [timestampObject] Optional timestamp. If given validate that you got the latest version.              This can be used to ensure that the invoice has not been changed since you last fetched it.              Defaults to latest version of the invoice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidGenerateCreditnotePost: async (guid: string, organizationId: string, timestampObject?: TimestampObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidGenerateCreditnotePost', 'guid', guid)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidGenerateCreditnotePost', 'organizationId', organizationId)
            const localVarPath = `/v1/{organizationId}/invoices/{guid}/generate-creditnote`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timestampObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get invoice as json or pdf.  Define the Accept header of your request to either \'application/json\' or \'application/octet-stream\'.  PDF\'s can only be generated from booked invoices.
         * @summary Get invoice as json or pdf
         * @param {string} guid 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidGet: async (guid: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidGet', 'guid', guid)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidGet', 'organizationId', organizationId)
            const localVarPath = `/v1/{organizationId}/invoices/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the mailouts for a specific invoice.
         * @summary List mailouts
         * @param {string} guid 
         * @param {string} organizationId 
         * @param {string} [changesSince] [Generic Filter Option] Only return mailouts that was created or updated after a given time.              If left empty, this filter will not be applied, and mailouts will be returned regardless of change history.              The time must be UTC and in the format \&#39;YYYY-MM-DDTHH:mm:ssZ\&#39; example: \&#39;2015-08-18T06:36:22Z\&#39;.
         * @param {boolean} [includeSms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidMailoutsGet: async (guid: string, organizationId: string, changesSince?: string, includeSms?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidMailoutsGet', 'guid', guid)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidMailoutsGet', 'organizationId', organizationId)
            const localVarPath = `/v1/{organizationId}/invoices/{guid}/mailouts`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (changesSince !== undefined) {
                localVarQueryParameter['changesSince'] = changesSince;
            }

            if (includeSms !== undefined) {
                localVarQueryParameter['includeSms'] = includeSms;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a payment from an invoice. Only booked invoices can have payments.
         * @summary Delete payment from invoice
         * @param {string} guid Guid of the invoice
         * @param {string} paymentGuid The payment guid
         * @param {string} organizationId 
         * @param {TimestampObject} [timestampObject] Version of the invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete: async (guid: string, paymentGuid: string, organizationId: string, timestampObject?: TimestampObject, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete', 'guid', guid)
            // verify required parameter 'paymentGuid' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete', 'paymentGuid', paymentGuid)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete', 'organizationId', organizationId)
            const localVarPath = `/v1/{organizationId}/invoices/{guid}/payments/{paymentGuid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"paymentGuid"}}`, encodeURIComponent(String(paymentGuid)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timestampObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a payment for an invoice. Payments can only be added to a booked invoice.
         * @summary Add payment to invoice
         * @param {string} guid Guid of the invoice
         * @param {string} organizationId 
         * @param {PaymentCreateModel} [paymentCreateModel] The payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidPaymentsPost: async (guid: string, organizationId: string, paymentCreateModel?: PaymentCreateModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidPaymentsPost', 'guid', guid)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesGuidPaymentsPost', 'organizationId', organizationId)
            const localVarPath = `/v1/{organizationId}/invoices/{guid}/payments`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentCreateModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new draft invoice. This invoice can be found in the \"Salg\" section of Dinero. A draft invoice will not count in the accounts untill booked.  Think about using the book and send endpoints after the draft has been created to further automate the booking process for the user.  Also note that the date on the invoice, should always be the date the invoice is sent to the customer.
         * @summary Create invoice
         * @param {string} organizationId 
         * @param {InvoiceCreateModel} [invoiceCreateModel] Model of the invoice to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesPost: async (organizationId: string, invoiceCreateModel?: InvoiceCreateModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesPost', 'organizationId', organizationId)
            const localVarPath = `/v1/{organizationId}/invoices`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceCreateModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get possible templates for invoices, which change the design and look of the invoice. Only possible to customize in Dineros UI.
         * @summary List invoice templates
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesTemplatesGet: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v1OrganizationIdInvoicesTemplatesGet', 'organizationId', organizationId)
            const localVarPath = `/v1/{organizationId}/invoices/templates`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an e-invoice to an EAN customer. This is a public system for electronic invoicing.
         * @summary Send invoice with EAN
         * @param {string} guid Guid of the invoice to send
         * @param {string} organizationId 
         * @param {EanSendModelV2} [eanSendModelV2] parameters for the Ean invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2OrganizationIdInvoicesGuidEInvoicePost: async (guid: string, organizationId: string, eanSendModelV2?: EanSendModelV2, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('v2OrganizationIdInvoicesGuidEInvoicePost', 'guid', guid)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v2OrganizationIdInvoicesGuidEInvoicePost', 'organizationId', organizationId)
            const localVarPath = `/v2/{organizationId}/invoices/{guid}/e-invoice`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eanSendModelV2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the email template for an invoice. This can be used to preview what will be sent out on the email. These standards can be overwritten during the sending phase.
         * @summary Get invoice email template
         * @param {string} guid Guid of the invoice to send
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2OrganizationIdInvoicesGuidEmailTemplateGet: async (guid: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('v2OrganizationIdInvoicesGuidEmailTemplateGet', 'guid', guid)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v2OrganizationIdInvoicesGuidEmailTemplateGet', 'organizationId', organizationId)
            const localVarPath = `/v2/{organizationId}/invoices/{guid}/email/template`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the payments for an invoice
         * @summary Get payments for invoice
         * @param {string} guid Guid of the invoice
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2OrganizationIdInvoicesGuidPaymentsGet: async (guid: string, organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('v2OrganizationIdInvoicesGuidPaymentsGet', 'guid', guid)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v2OrganizationIdInvoicesGuidPaymentsGet', 'organizationId', organizationId)
            const localVarPath = `/v2/{organizationId}/invoices/{guid}/payments`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send electronic invoice to following destinations: P, SE, EAN/GLN, Danish vat (CVR) -numbers
         * @summary Send electronic invoice
         * @param {string} guid Guid of the invoice to send
         * @param {string} organizationId 
         * @param {EInvoiceSendModel} [eInvoiceSendModel] parameters for electronic invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v3OrganizationIdInvoicesGuidEInvoicePost: async (guid: string, organizationId: string, eInvoiceSendModel?: EInvoiceSendModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('v3OrganizationIdInvoicesGuidEInvoicePost', 'guid', guid)
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('v3OrganizationIdInvoicesGuidEInvoicePost', 'organizationId', organizationId)
            const localVarPath = `/v3/{organizationId}/invoices/{guid}/e-invoice`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)))
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eInvoiceSendModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Update an existing invoice. The invoice cannot be updated if booked. Note that the put request per rest standard will update the entire invoice and not only the fields you send.
         * @summary Update invoice
         * @param {string} guid Unique identifier for the invoice information
         * @param {string} organizationId 
         * @param {InvoiceUpdateModel} [invoiceUpdateModel] Content of the invoice to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v12OrganizationIdInvoicesGuidPut(guid: string, organizationId: string, invoiceUpdateModel?: InvoiceUpdateModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdatedResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v12OrganizationIdInvoicesGuidPut(guid, organizationId, invoiceUpdateModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v12OrganizationIdInvoicesGuidPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a invoice to get total, line sums and payment date calculations.
         * @summary Get invoice totals
         * @param {string} organizationId 
         * @param {InvoiceCreateFetchModel} [invoiceCreateFetchModel] Model of the invoice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrganizationIdInvoicesFetchPost(organizationId: string, invoiceCreateFetchModel?: InvoiceCreateFetchModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceFetchReadModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrganizationIdInvoicesFetchPost(organizationId, invoiceCreateFetchModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v1OrganizationIdInvoicesFetchPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of invoices for the organization.  This can return quite a long list of invoices, consider using the changesSince filter to only return invoices that have been changed since the last time you fetched the list.  Also note that deleted invoices will not be returned on this list per default.
         * @summary List invoices
         * @param {string} organizationId 
         * @param {string} [startDate] Start date in format \&#39;YYYY-MM-DD\&#39; example \&#39;2015-01-01\&#39;. If you define a start date, you also need to define an end date. Note that drafts are not affected by this filter.
         * @param {string} [endDate] End date in format \&#39;YYYY-MM-DD\&#39; example \&#39;2015-01-01\&#39;. If you define an end date, you also need to define a start date.  Note that drafts are not affected by this filter.
         * @param {string} [fields] A comma separated list of fields to include in the response.              Possible values are:              Number, Guid, ExternalReference, ContactName, ContactGuid, Date, PaymentDate, Description, Currency, Status, MailOutStatus, LatestMailOutType, TotalExclVatInDkk, TotalInclVatInDkk              TotalExclVat, TotalInclVat, CreatedAt, UpdatedAt and DeletedAt.              If null, defaults to Guid,ContactName,Date,Description.              Notice that it\&#39;s not case sensitive, the property name will be returned the way you request it.
         * @param {string} [freeTextSearch] A free text search performed on Number, ContactName, Description and TotalInclTax
         * @param {string} [statusFilter] Filter on Status. You can choose Draft, Booked, Paid, OverPaid or Overdue. You can add multible filters example: \&#39;Paid,OverPaid,Overdue\&#39;. If left empty no filter is applied.
         * @param {string} [queryFilter] Filtering can be applied to following fields:              ExternalReference, ContactGuid, Description. See API documentation for filtering format. If left empty no filtering is applied.
         * @param {string} [changesSince] [Generic Filter Option] Only return invoices that was created, deleted or updated at or after given time.              If left empty, this filter will not be applied, and invoices will be returned regardless of change history.              The time must be UTC and in the format \&#39;YYYY-MM-DDTHH:mm:ssZ\&#39; example: \&#39;2015-08-18T06:36:22Z\&#39;.
         * @param {boolean} [deletedOnly] [Generic Filter Option] Only select deleted invoices. If left empty, will defaults to false.
         * @param {number} [page] The 0-based page number
         * @param {number} [pageSize] The maximum number of items to include in a page. Maximum 1000.
         * @param {string} [sort] A comma separated list of fields to sort on. Possible values are: VoucherNumber, VoucherDate, Status and Contact.
         * @param {string} [sortOrder] Sort order. Valid values are ascending and descending. Field Status is always sorted in the order Draft, Overdue, Booked, OverPaid and Paid.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrganizationIdInvoicesGet(organizationId: string, startDate?: string, endDate?: string, fields?: string, freeTextSearch?: string, statusFilter?: string, queryFilter?: string, changesSince?: string, deletedOnly?: boolean, page?: number, pageSize?: number, sort?: string, sortOrder?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SalesVoucherReadListModelDineroCollection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrganizationIdInvoicesGet(organizationId, startDate, endDate, fields, freeTextSearch, statusFilter, queryFilter, changesSince, deletedOnly, page, pageSize, sort, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v1OrganizationIdInvoicesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Book invoice. Booking means actually posting the invoice to the accounts. A booked invoice can also be send via email, sms or as an e-invoice.
         * @summary Book invoice
         * @param {string} guid Guid of the invoice to book
         * @param {string} organizationId 
         * @param {BookModel} [bookModel] Data used for the booking transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrganizationIdInvoicesGuidBookPost(guid: string, organizationId: string, bookModel?: BookModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceReadModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrganizationIdInvoicesGuidBookPost(guid, organizationId, bookModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v1OrganizationIdInvoicesGuidBookPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete invoice. The invoice should not be deleted if booked. In that case a creditnote would be the correct way to cancel the invoice.
         * @summary Delete invoice
         * @param {string} guid Unique identifier for the invoice
         * @param {string} organizationId 
         * @param {TimestampObject} [timestampObject] optional timestamp to verify version before deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrganizationIdInvoicesGuidDelete(guid: string, organizationId: string, timestampObject?: TimestampObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrganizationIdInvoicesGuidDelete(guid, organizationId, timestampObject, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v1OrganizationIdInvoicesGuidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send an email with link to a public version of the invoice where it can be printed or downloaded as a pdf. The invoice must be booked.
         * @summary Send invoice email
         * @param {string} guid Guid of the invoice to send
         * @param {string} organizationId 
         * @param {ApiMailoutModel} [apiMailoutModel] Model of the email to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrganizationIdInvoicesGuidEmailPost(guid: string, organizationId: string, apiMailoutModel?: ApiMailoutModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailSentModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrganizationIdInvoicesGuidEmailPost(guid, organizationId, apiMailoutModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v1OrganizationIdInvoicesGuidEmailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a pre reminder email with link to a public version of the invoice where it can be printed or downloaded as a pdf.  The invoice needs to be overdue to send the reminder.  A pre-reminder is a mail reminding the customer, that the invoice is overdue. This will not cause a reminder to be created in Dinero, this is only a mailout.
         * @summary Send invoice prereminder
         * @param {string} guid Guid of the invoice to send
         * @param {string} organizationId 
         * @param {ApiMailoutModel} [apiMailoutModel] Model of the email to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrganizationIdInvoicesGuidEmailPreReminderPost(guid: string, organizationId: string, apiMailoutModel?: ApiMailoutModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrganizationIdInvoicesGuidEmailPreReminderPost(guid, organizationId, apiMailoutModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v1OrganizationIdInvoicesGuidEmailPreReminderPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the email template for a pre-reminder. This can be used to preview what will be sent out on the email. These standards can be overwritten during the sending phase.
         * @summary Get pre-reminder template
         * @param {string} guid Guid of the invoice to send
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrganizationIdInvoicesGuidEmailPreReminderTemplateGet(guid: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MailoutTemplateReadModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrganizationIdInvoicesGuidEmailPreReminderTemplateGet(guid, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v1OrganizationIdInvoicesGuidEmailPreReminderTemplateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate and saves a creditnote draft of a given booked invoice. If you need to create a standalone creditnote or a partial creditnote, please look at the creditnote category further down the documentation. Remeber to also book and send the creditnote to fully automate the booking process.
         * @summary Create credit note from invoice
         * @param {string} guid Guid of the invoice
         * @param {string} organizationId 
         * @param {TimestampObject} [timestampObject] Optional timestamp. If given validate that you got the latest version.              This can be used to ensure that the invoice has not been changed since you last fetched it.              Defaults to latest version of the invoice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrganizationIdInvoicesGuidGenerateCreditnotePost(guid: string, organizationId: string, timestampObject?: TimestampObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrganizationIdInvoicesGuidGenerateCreditnotePost(guid, organizationId, timestampObject, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v1OrganizationIdInvoicesGuidGenerateCreditnotePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get invoice as json or pdf.  Define the Accept header of your request to either \'application/json\' or \'application/octet-stream\'.  PDF\'s can only be generated from booked invoices.
         * @summary Get invoice as json or pdf
         * @param {string} guid 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrganizationIdInvoicesGuidGet(guid: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceReadModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrganizationIdInvoicesGuidGet(guid, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v1OrganizationIdInvoicesGuidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the mailouts for a specific invoice.
         * @summary List mailouts
         * @param {string} guid 
         * @param {string} organizationId 
         * @param {string} [changesSince] [Generic Filter Option] Only return mailouts that was created or updated after a given time.              If left empty, this filter will not be applied, and mailouts will be returned regardless of change history.              The time must be UTC and in the format \&#39;YYYY-MM-DDTHH:mm:ssZ\&#39; example: \&#39;2015-08-18T06:36:22Z\&#39;.
         * @param {boolean} [includeSms] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrganizationIdInvoicesGuidMailoutsGet(guid: string, organizationId: string, changesSince?: string, includeSms?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VoucherMailoutReadModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrganizationIdInvoicesGuidMailoutsGet(guid, organizationId, changesSince, includeSms, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v1OrganizationIdInvoicesGuidMailoutsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a payment from an invoice. Only booked invoices can have payments.
         * @summary Delete payment from invoice
         * @param {string} guid Guid of the invoice
         * @param {string} paymentGuid The payment guid
         * @param {string} organizationId 
         * @param {TimestampObject} [timestampObject] Version of the invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete(guid: string, paymentGuid: string, organizationId: string, timestampObject?: TimestampObject, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete(guid, paymentGuid, organizationId, timestampObject, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a payment for an invoice. Payments can only be added to a booked invoice.
         * @summary Add payment to invoice
         * @param {string} guid Guid of the invoice
         * @param {string} organizationId 
         * @param {PaymentCreateModel} [paymentCreateModel] The payment details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrganizationIdInvoicesGuidPaymentsPost(guid: string, organizationId: string, paymentCreateModel?: PaymentCreateModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedPaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrganizationIdInvoicesGuidPaymentsPost(guid, organizationId, paymentCreateModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v1OrganizationIdInvoicesGuidPaymentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new draft invoice. This invoice can be found in the \"Salg\" section of Dinero. A draft invoice will not count in the accounts untill booked.  Think about using the book and send endpoints after the draft has been created to further automate the booking process for the user.  Also note that the date on the invoice, should always be the date the invoice is sent to the customer.
         * @summary Create invoice
         * @param {string} organizationId 
         * @param {InvoiceCreateModel} [invoiceCreateModel] Model of the invoice to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrganizationIdInvoicesPost(organizationId: string, invoiceCreateModel?: InvoiceCreateModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrganizationIdInvoicesPost(organizationId, invoiceCreateModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v1OrganizationIdInvoicesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get possible templates for invoices, which change the design and look of the invoice. Only possible to customize in Dineros UI.
         * @summary List invoice templates
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v1OrganizationIdInvoicesTemplatesGet(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoiceTemplateModel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v1OrganizationIdInvoicesTemplatesGet(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v1OrganizationIdInvoicesTemplatesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send an e-invoice to an EAN customer. This is a public system for electronic invoicing.
         * @summary Send invoice with EAN
         * @param {string} guid Guid of the invoice to send
         * @param {string} organizationId 
         * @param {EanSendModelV2} [eanSendModelV2] parameters for the Ean invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2OrganizationIdInvoicesGuidEInvoicePost(guid: string, organizationId: string, eanSendModelV2?: EanSendModelV2, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2OrganizationIdInvoicesGuidEInvoicePost(guid, organizationId, eanSendModelV2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v2OrganizationIdInvoicesGuidEInvoicePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the email template for an invoice. This can be used to preview what will be sent out on the email. These standards can be overwritten during the sending phase.
         * @summary Get invoice email template
         * @param {string} guid Guid of the invoice to send
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2OrganizationIdInvoicesGuidEmailTemplateGet(guid: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MailoutTemplateReadModelV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2OrganizationIdInvoicesGuidEmailTemplateGet(guid, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v2OrganizationIdInvoicesGuidEmailTemplateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the payments for an invoice
         * @summary Get payments for invoice
         * @param {string} guid Guid of the invoice
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2OrganizationIdInvoicesGuidPaymentsGet(guid: string, organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoicePaymentsModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2OrganizationIdInvoicesGuidPaymentsGet(guid, organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v2OrganizationIdInvoicesGuidPaymentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send electronic invoice to following destinations: P, SE, EAN/GLN, Danish vat (CVR) -numbers
         * @summary Send electronic invoice
         * @param {string} guid Guid of the invoice to send
         * @param {string} organizationId 
         * @param {EInvoiceSendModel} [eInvoiceSendModel] parameters for electronic invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v3OrganizationIdInvoicesGuidEInvoicePost(guid: string, organizationId: string, eInvoiceSendModel?: EInvoiceSendModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v3OrganizationIdInvoicesGuidEInvoicePost(guid, organizationId, eInvoiceSendModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.v3OrganizationIdInvoicesGuidEInvoicePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesApiFp(configuration)
    return {
        /**
         * Update an existing invoice. The invoice cannot be updated if booked. Note that the put request per rest standard will update the entire invoice and not only the fields you send.
         * @summary Update invoice
         * @param {InvoicesApiV12OrganizationIdInvoicesGuidPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v12OrganizationIdInvoicesGuidPut(requestParameters: InvoicesApiV12OrganizationIdInvoicesGuidPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdatedResponseModel> {
            return localVarFp.v12OrganizationIdInvoicesGuidPut(requestParameters.guid, requestParameters.organizationId, requestParameters.invoiceUpdateModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a invoice to get total, line sums and payment date calculations.
         * @summary Get invoice totals
         * @param {InvoicesApiV1OrganizationIdInvoicesFetchPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesFetchPost(requestParameters: InvoicesApiV1OrganizationIdInvoicesFetchPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<InvoiceFetchReadModel> {
            return localVarFp.v1OrganizationIdInvoicesFetchPost(requestParameters.organizationId, requestParameters.invoiceCreateFetchModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of invoices for the organization.  This can return quite a long list of invoices, consider using the changesSince filter to only return invoices that have been changed since the last time you fetched the list.  Also note that deleted invoices will not be returned on this list per default.
         * @summary List invoices
         * @param {InvoicesApiV1OrganizationIdInvoicesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGet(requestParameters: InvoicesApiV1OrganizationIdInvoicesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<SalesVoucherReadListModelDineroCollection> {
            return localVarFp.v1OrganizationIdInvoicesGet(requestParameters.organizationId, requestParameters.startDate, requestParameters.endDate, requestParameters.fields, requestParameters.freeTextSearch, requestParameters.statusFilter, requestParameters.queryFilter, requestParameters.changesSince, requestParameters.deletedOnly, requestParameters.page, requestParameters.pageSize, requestParameters.sort, requestParameters.sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Book invoice. Booking means actually posting the invoice to the accounts. A booked invoice can also be send via email, sms or as an e-invoice.
         * @summary Book invoice
         * @param {InvoicesApiV1OrganizationIdInvoicesGuidBookPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidBookPost(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidBookPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<InvoiceReadModel> {
            return localVarFp.v1OrganizationIdInvoicesGuidBookPost(requestParameters.guid, requestParameters.organizationId, requestParameters.bookModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete invoice. The invoice should not be deleted if booked. In that case a creditnote would be the correct way to cancel the invoice.
         * @summary Delete invoice
         * @param {InvoicesApiV1OrganizationIdInvoicesGuidDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidDelete(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1OrganizationIdInvoicesGuidDelete(requestParameters.guid, requestParameters.organizationId, requestParameters.timestampObject, options).then((request) => request(axios, basePath));
        },
        /**
         * Send an email with link to a public version of the invoice where it can be printed or downloaded as a pdf. The invoice must be booked.
         * @summary Send invoice email
         * @param {InvoicesApiV1OrganizationIdInvoicesGuidEmailPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidEmailPost(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidEmailPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<EmailSentModel> {
            return localVarFp.v1OrganizationIdInvoicesGuidEmailPost(requestParameters.guid, requestParameters.organizationId, requestParameters.apiMailoutModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a pre reminder email with link to a public version of the invoice where it can be printed or downloaded as a pdf.  The invoice needs to be overdue to send the reminder.  A pre-reminder is a mail reminding the customer, that the invoice is overdue. This will not cause a reminder to be created in Dinero, this is only a mailout.
         * @summary Send invoice prereminder
         * @param {InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidEmailPreReminderPost(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v1OrganizationIdInvoicesGuidEmailPreReminderPost(requestParameters.guid, requestParameters.organizationId, requestParameters.apiMailoutModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the email template for a pre-reminder. This can be used to preview what will be sent out on the email. These standards can be overwritten during the sending phase.
         * @summary Get pre-reminder template
         * @param {InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderTemplateGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidEmailPreReminderTemplateGet(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderTemplateGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<MailoutTemplateReadModel> {
            return localVarFp.v1OrganizationIdInvoicesGuidEmailPreReminderTemplateGet(requestParameters.guid, requestParameters.organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate and saves a creditnote draft of a given booked invoice. If you need to create a standalone creditnote or a partial creditnote, please look at the creditnote category further down the documentation. Remeber to also book and send the creditnote to fully automate the booking process.
         * @summary Create credit note from invoice
         * @param {InvoicesApiV1OrganizationIdInvoicesGuidGenerateCreditnotePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidGenerateCreditnotePost(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidGenerateCreditnotePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatedResponseModel> {
            return localVarFp.v1OrganizationIdInvoicesGuidGenerateCreditnotePost(requestParameters.guid, requestParameters.organizationId, requestParameters.timestampObject, options).then((request) => request(axios, basePath));
        },
        /**
         * Get invoice as json or pdf.  Define the Accept header of your request to either \'application/json\' or \'application/octet-stream\'.  PDF\'s can only be generated from booked invoices.
         * @summary Get invoice as json or pdf
         * @param {InvoicesApiV1OrganizationIdInvoicesGuidGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidGet(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InvoiceReadModel> {
            return localVarFp.v1OrganizationIdInvoicesGuidGet(requestParameters.guid, requestParameters.organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the mailouts for a specific invoice.
         * @summary List mailouts
         * @param {InvoicesApiV1OrganizationIdInvoicesGuidMailoutsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidMailoutsGet(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidMailoutsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<VoucherMailoutReadModel> {
            return localVarFp.v1OrganizationIdInvoicesGuidMailoutsGet(requestParameters.guid, requestParameters.organizationId, requestParameters.changesSince, requestParameters.includeSms, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a payment from an invoice. Only booked invoices can have payments.
         * @summary Delete payment from invoice
         * @param {InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPaymentGuidDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPaymentGuidDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeletedPaymentResponse> {
            return localVarFp.v1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete(requestParameters.guid, requestParameters.paymentGuid, requestParameters.organizationId, requestParameters.timestampObject, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a payment for an invoice. Payments can only be added to a booked invoice.
         * @summary Add payment to invoice
         * @param {InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesGuidPaymentsPost(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatedPaymentResponse> {
            return localVarFp.v1OrganizationIdInvoicesGuidPaymentsPost(requestParameters.guid, requestParameters.organizationId, requestParameters.paymentCreateModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new draft invoice. This invoice can be found in the \"Salg\" section of Dinero. A draft invoice will not count in the accounts untill booked.  Think about using the book and send endpoints after the draft has been created to further automate the booking process for the user.  Also note that the date on the invoice, should always be the date the invoice is sent to the customer.
         * @summary Create invoice
         * @param {InvoicesApiV1OrganizationIdInvoicesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesPost(requestParameters: InvoicesApiV1OrganizationIdInvoicesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreatedResponseModel> {
            return localVarFp.v1OrganizationIdInvoicesPost(requestParameters.organizationId, requestParameters.invoiceCreateModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Get possible templates for invoices, which change the design and look of the invoice. Only possible to customize in Dineros UI.
         * @summary List invoice templates
         * @param {InvoicesApiV1OrganizationIdInvoicesTemplatesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1OrganizationIdInvoicesTemplatesGet(requestParameters: InvoicesApiV1OrganizationIdInvoicesTemplatesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<InvoiceTemplateModel>> {
            return localVarFp.v1OrganizationIdInvoicesTemplatesGet(requestParameters.organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Send an e-invoice to an EAN customer. This is a public system for electronic invoicing.
         * @summary Send invoice with EAN
         * @param {InvoicesApiV2OrganizationIdInvoicesGuidEInvoicePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2OrganizationIdInvoicesGuidEInvoicePost(requestParameters: InvoicesApiV2OrganizationIdInvoicesGuidEInvoicePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v2OrganizationIdInvoicesGuidEInvoicePost(requestParameters.guid, requestParameters.organizationId, requestParameters.eanSendModelV2, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the email template for an invoice. This can be used to preview what will be sent out on the email. These standards can be overwritten during the sending phase.
         * @summary Get invoice email template
         * @param {InvoicesApiV2OrganizationIdInvoicesGuidEmailTemplateGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2OrganizationIdInvoicesGuidEmailTemplateGet(requestParameters: InvoicesApiV2OrganizationIdInvoicesGuidEmailTemplateGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<MailoutTemplateReadModelV2> {
            return localVarFp.v2OrganizationIdInvoicesGuidEmailTemplateGet(requestParameters.guid, requestParameters.organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the payments for an invoice
         * @summary Get payments for invoice
         * @param {InvoicesApiV2OrganizationIdInvoicesGuidPaymentsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2OrganizationIdInvoicesGuidPaymentsGet(requestParameters: InvoicesApiV2OrganizationIdInvoicesGuidPaymentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InvoicePaymentsModel> {
            return localVarFp.v2OrganizationIdInvoicesGuidPaymentsGet(requestParameters.guid, requestParameters.organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Send electronic invoice to following destinations: P, SE, EAN/GLN, Danish vat (CVR) -numbers
         * @summary Send electronic invoice
         * @param {InvoicesApiV3OrganizationIdInvoicesGuidEInvoicePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v3OrganizationIdInvoicesGuidEInvoicePost(requestParameters: InvoicesApiV3OrganizationIdInvoicesGuidEInvoicePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.v3OrganizationIdInvoicesGuidEInvoicePost(requestParameters.guid, requestParameters.organizationId, requestParameters.eInvoiceSendModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for v12OrganizationIdInvoicesGuidPut operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV12OrganizationIdInvoicesGuidPutRequest
 */
export interface InvoicesApiV12OrganizationIdInvoicesGuidPutRequest {
    /**
     * Unique identifier for the invoice information
     * @type {string}
     * @memberof InvoicesApiV12OrganizationIdInvoicesGuidPut
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV12OrganizationIdInvoicesGuidPut
     */
    readonly organizationId: string

    /**
     * Content of the invoice to update
     * @type {InvoiceUpdateModel}
     * @memberof InvoicesApiV12OrganizationIdInvoicesGuidPut
     */
    readonly invoiceUpdateModel?: InvoiceUpdateModel
}

/**
 * Request parameters for v1OrganizationIdInvoicesFetchPost operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV1OrganizationIdInvoicesFetchPostRequest
 */
export interface InvoicesApiV1OrganizationIdInvoicesFetchPostRequest {
    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesFetchPost
     */
    readonly organizationId: string

    /**
     * Model of the invoice.
     * @type {InvoiceCreateFetchModel}
     * @memberof InvoicesApiV1OrganizationIdInvoicesFetchPost
     */
    readonly invoiceCreateFetchModel?: InvoiceCreateFetchModel
}

/**
 * Request parameters for v1OrganizationIdInvoicesGet operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV1OrganizationIdInvoicesGetRequest
 */
export interface InvoicesApiV1OrganizationIdInvoicesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGet
     */
    readonly organizationId: string

    /**
     * Start date in format \&#39;YYYY-MM-DD\&#39; example \&#39;2015-01-01\&#39;. If you define a start date, you also need to define an end date. Note that drafts are not affected by this filter.
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGet
     */
    readonly startDate?: string

    /**
     * End date in format \&#39;YYYY-MM-DD\&#39; example \&#39;2015-01-01\&#39;. If you define an end date, you also need to define a start date.  Note that drafts are not affected by this filter.
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGet
     */
    readonly endDate?: string

    /**
     * A comma separated list of fields to include in the response.              Possible values are:              Number, Guid, ExternalReference, ContactName, ContactGuid, Date, PaymentDate, Description, Currency, Status, MailOutStatus, LatestMailOutType, TotalExclVatInDkk, TotalInclVatInDkk              TotalExclVat, TotalInclVat, CreatedAt, UpdatedAt and DeletedAt.              If null, defaults to Guid,ContactName,Date,Description.              Notice that it\&#39;s not case sensitive, the property name will be returned the way you request it.
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGet
     */
    readonly fields?: string

    /**
     * A free text search performed on Number, ContactName, Description and TotalInclTax
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGet
     */
    readonly freeTextSearch?: string

    /**
     * Filter on Status. You can choose Draft, Booked, Paid, OverPaid or Overdue. You can add multible filters example: \&#39;Paid,OverPaid,Overdue\&#39;. If left empty no filter is applied.
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGet
     */
    readonly statusFilter?: string

    /**
     * Filtering can be applied to following fields:              ExternalReference, ContactGuid, Description. See API documentation for filtering format. If left empty no filtering is applied.
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGet
     */
    readonly queryFilter?: string

    /**
     * [Generic Filter Option] Only return invoices that was created, deleted or updated at or after given time.              If left empty, this filter will not be applied, and invoices will be returned regardless of change history.              The time must be UTC and in the format \&#39;YYYY-MM-DDTHH:mm:ssZ\&#39; example: \&#39;2015-08-18T06:36:22Z\&#39;.
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGet
     */
    readonly changesSince?: string

    /**
     * [Generic Filter Option] Only select deleted invoices. If left empty, will defaults to false.
     * @type {boolean}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGet
     */
    readonly deletedOnly?: boolean

    /**
     * The 0-based page number
     * @type {number}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGet
     */
    readonly page?: number

    /**
     * The maximum number of items to include in a page. Maximum 1000.
     * @type {number}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGet
     */
    readonly pageSize?: number

    /**
     * A comma separated list of fields to sort on. Possible values are: VoucherNumber, VoucherDate, Status and Contact.
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGet
     */
    readonly sort?: string

    /**
     * Sort order. Valid values are ascending and descending. Field Status is always sorted in the order Draft, Overdue, Booked, OverPaid and Paid.
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGet
     */
    readonly sortOrder?: string
}

/**
 * Request parameters for v1OrganizationIdInvoicesGuidBookPost operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV1OrganizationIdInvoicesGuidBookPostRequest
 */
export interface InvoicesApiV1OrganizationIdInvoicesGuidBookPostRequest {
    /**
     * Guid of the invoice to book
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidBookPost
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidBookPost
     */
    readonly organizationId: string

    /**
     * Data used for the booking transaction
     * @type {BookModel}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidBookPost
     */
    readonly bookModel?: BookModel
}

/**
 * Request parameters for v1OrganizationIdInvoicesGuidDelete operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV1OrganizationIdInvoicesGuidDeleteRequest
 */
export interface InvoicesApiV1OrganizationIdInvoicesGuidDeleteRequest {
    /**
     * Unique identifier for the invoice
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidDelete
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidDelete
     */
    readonly organizationId: string

    /**
     * optional timestamp to verify version before deletion
     * @type {TimestampObject}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidDelete
     */
    readonly timestampObject?: TimestampObject
}

/**
 * Request parameters for v1OrganizationIdInvoicesGuidEmailPost operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV1OrganizationIdInvoicesGuidEmailPostRequest
 */
export interface InvoicesApiV1OrganizationIdInvoicesGuidEmailPostRequest {
    /**
     * Guid of the invoice to send
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidEmailPost
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidEmailPost
     */
    readonly organizationId: string

    /**
     * Model of the email to send
     * @type {ApiMailoutModel}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidEmailPost
     */
    readonly apiMailoutModel?: ApiMailoutModel
}

/**
 * Request parameters for v1OrganizationIdInvoicesGuidEmailPreReminderPost operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderPostRequest
 */
export interface InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderPostRequest {
    /**
     * Guid of the invoice to send
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderPost
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderPost
     */
    readonly organizationId: string

    /**
     * Model of the email to send
     * @type {ApiMailoutModel}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderPost
     */
    readonly apiMailoutModel?: ApiMailoutModel
}

/**
 * Request parameters for v1OrganizationIdInvoicesGuidEmailPreReminderTemplateGet operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderTemplateGetRequest
 */
export interface InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderTemplateGetRequest {
    /**
     * Guid of the invoice to send
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderTemplateGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderTemplateGet
     */
    readonly organizationId: string
}

/**
 * Request parameters for v1OrganizationIdInvoicesGuidGenerateCreditnotePost operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV1OrganizationIdInvoicesGuidGenerateCreditnotePostRequest
 */
export interface InvoicesApiV1OrganizationIdInvoicesGuidGenerateCreditnotePostRequest {
    /**
     * Guid of the invoice
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidGenerateCreditnotePost
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidGenerateCreditnotePost
     */
    readonly organizationId: string

    /**
     * Optional timestamp. If given validate that you got the latest version.              This can be used to ensure that the invoice has not been changed since you last fetched it.              Defaults to latest version of the invoice.
     * @type {TimestampObject}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidGenerateCreditnotePost
     */
    readonly timestampObject?: TimestampObject
}

/**
 * Request parameters for v1OrganizationIdInvoicesGuidGet operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV1OrganizationIdInvoicesGuidGetRequest
 */
export interface InvoicesApiV1OrganizationIdInvoicesGuidGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidGet
     */
    readonly organizationId: string
}

/**
 * Request parameters for v1OrganizationIdInvoicesGuidMailoutsGet operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV1OrganizationIdInvoicesGuidMailoutsGetRequest
 */
export interface InvoicesApiV1OrganizationIdInvoicesGuidMailoutsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidMailoutsGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidMailoutsGet
     */
    readonly organizationId: string

    /**
     * [Generic Filter Option] Only return mailouts that was created or updated after a given time.              If left empty, this filter will not be applied, and mailouts will be returned regardless of change history.              The time must be UTC and in the format \&#39;YYYY-MM-DDTHH:mm:ssZ\&#39; example: \&#39;2015-08-18T06:36:22Z\&#39;.
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidMailoutsGet
     */
    readonly changesSince?: string

    /**
     * 
     * @type {boolean}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidMailoutsGet
     */
    readonly includeSms?: boolean
}

/**
 * Request parameters for v1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPaymentGuidDeleteRequest
 */
export interface InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPaymentGuidDeleteRequest {
    /**
     * Guid of the invoice
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete
     */
    readonly guid: string

    /**
     * The payment guid
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete
     */
    readonly paymentGuid: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete
     */
    readonly organizationId: string

    /**
     * Version of the invoice
     * @type {TimestampObject}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete
     */
    readonly timestampObject?: TimestampObject
}

/**
 * Request parameters for v1OrganizationIdInvoicesGuidPaymentsPost operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPostRequest
 */
export interface InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPostRequest {
    /**
     * Guid of the invoice
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPost
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPost
     */
    readonly organizationId: string

    /**
     * The payment details
     * @type {PaymentCreateModel}
     * @memberof InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPost
     */
    readonly paymentCreateModel?: PaymentCreateModel
}

/**
 * Request parameters for v1OrganizationIdInvoicesPost operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV1OrganizationIdInvoicesPostRequest
 */
export interface InvoicesApiV1OrganizationIdInvoicesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesPost
     */
    readonly organizationId: string

    /**
     * Model of the invoice to save.
     * @type {InvoiceCreateModel}
     * @memberof InvoicesApiV1OrganizationIdInvoicesPost
     */
    readonly invoiceCreateModel?: InvoiceCreateModel
}

/**
 * Request parameters for v1OrganizationIdInvoicesTemplatesGet operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV1OrganizationIdInvoicesTemplatesGetRequest
 */
export interface InvoicesApiV1OrganizationIdInvoicesTemplatesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV1OrganizationIdInvoicesTemplatesGet
     */
    readonly organizationId: string
}

/**
 * Request parameters for v2OrganizationIdInvoicesGuidEInvoicePost operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV2OrganizationIdInvoicesGuidEInvoicePostRequest
 */
export interface InvoicesApiV2OrganizationIdInvoicesGuidEInvoicePostRequest {
    /**
     * Guid of the invoice to send
     * @type {string}
     * @memberof InvoicesApiV2OrganizationIdInvoicesGuidEInvoicePost
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV2OrganizationIdInvoicesGuidEInvoicePost
     */
    readonly organizationId: string

    /**
     * parameters for the Ean invoice
     * @type {EanSendModelV2}
     * @memberof InvoicesApiV2OrganizationIdInvoicesGuidEInvoicePost
     */
    readonly eanSendModelV2?: EanSendModelV2
}

/**
 * Request parameters for v2OrganizationIdInvoicesGuidEmailTemplateGet operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV2OrganizationIdInvoicesGuidEmailTemplateGetRequest
 */
export interface InvoicesApiV2OrganizationIdInvoicesGuidEmailTemplateGetRequest {
    /**
     * Guid of the invoice to send
     * @type {string}
     * @memberof InvoicesApiV2OrganizationIdInvoicesGuidEmailTemplateGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV2OrganizationIdInvoicesGuidEmailTemplateGet
     */
    readonly organizationId: string
}

/**
 * Request parameters for v2OrganizationIdInvoicesGuidPaymentsGet operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV2OrganizationIdInvoicesGuidPaymentsGetRequest
 */
export interface InvoicesApiV2OrganizationIdInvoicesGuidPaymentsGetRequest {
    /**
     * Guid of the invoice
     * @type {string}
     * @memberof InvoicesApiV2OrganizationIdInvoicesGuidPaymentsGet
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV2OrganizationIdInvoicesGuidPaymentsGet
     */
    readonly organizationId: string
}

/**
 * Request parameters for v3OrganizationIdInvoicesGuidEInvoicePost operation in InvoicesApi.
 * @export
 * @interface InvoicesApiV3OrganizationIdInvoicesGuidEInvoicePostRequest
 */
export interface InvoicesApiV3OrganizationIdInvoicesGuidEInvoicePostRequest {
    /**
     * Guid of the invoice to send
     * @type {string}
     * @memberof InvoicesApiV3OrganizationIdInvoicesGuidEInvoicePost
     */
    readonly guid: string

    /**
     * 
     * @type {string}
     * @memberof InvoicesApiV3OrganizationIdInvoicesGuidEInvoicePost
     */
    readonly organizationId: string

    /**
     * parameters for electronic invoice
     * @type {EInvoiceSendModel}
     * @memberof InvoicesApiV3OrganizationIdInvoicesGuidEInvoicePost
     */
    readonly eInvoiceSendModel?: EInvoiceSendModel
}

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
    /**
     * Update an existing invoice. The invoice cannot be updated if booked. Note that the put request per rest standard will update the entire invoice and not only the fields you send.
     * @summary Update invoice
     * @param {InvoicesApiV12OrganizationIdInvoicesGuidPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v12OrganizationIdInvoicesGuidPut(requestParameters: InvoicesApiV12OrganizationIdInvoicesGuidPutRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v12OrganizationIdInvoicesGuidPut(requestParameters.guid, requestParameters.organizationId, requestParameters.invoiceUpdateModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a invoice to get total, line sums and payment date calculations.
     * @summary Get invoice totals
     * @param {InvoicesApiV1OrganizationIdInvoicesFetchPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v1OrganizationIdInvoicesFetchPost(requestParameters: InvoicesApiV1OrganizationIdInvoicesFetchPostRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v1OrganizationIdInvoicesFetchPost(requestParameters.organizationId, requestParameters.invoiceCreateFetchModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of invoices for the organization.  This can return quite a long list of invoices, consider using the changesSince filter to only return invoices that have been changed since the last time you fetched the list.  Also note that deleted invoices will not be returned on this list per default.
     * @summary List invoices
     * @param {InvoicesApiV1OrganizationIdInvoicesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v1OrganizationIdInvoicesGet(requestParameters: InvoicesApiV1OrganizationIdInvoicesGetRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v1OrganizationIdInvoicesGet(requestParameters.organizationId, requestParameters.startDate, requestParameters.endDate, requestParameters.fields, requestParameters.freeTextSearch, requestParameters.statusFilter, requestParameters.queryFilter, requestParameters.changesSince, requestParameters.deletedOnly, requestParameters.page, requestParameters.pageSize, requestParameters.sort, requestParameters.sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Book invoice. Booking means actually posting the invoice to the accounts. A booked invoice can also be send via email, sms or as an e-invoice.
     * @summary Book invoice
     * @param {InvoicesApiV1OrganizationIdInvoicesGuidBookPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v1OrganizationIdInvoicesGuidBookPost(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidBookPostRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v1OrganizationIdInvoicesGuidBookPost(requestParameters.guid, requestParameters.organizationId, requestParameters.bookModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete invoice. The invoice should not be deleted if booked. In that case a creditnote would be the correct way to cancel the invoice.
     * @summary Delete invoice
     * @param {InvoicesApiV1OrganizationIdInvoicesGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v1OrganizationIdInvoicesGuidDelete(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidDeleteRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v1OrganizationIdInvoicesGuidDelete(requestParameters.guid, requestParameters.organizationId, requestParameters.timestampObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send an email with link to a public version of the invoice where it can be printed or downloaded as a pdf. The invoice must be booked.
     * @summary Send invoice email
     * @param {InvoicesApiV1OrganizationIdInvoicesGuidEmailPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v1OrganizationIdInvoicesGuidEmailPost(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidEmailPostRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v1OrganizationIdInvoicesGuidEmailPost(requestParameters.guid, requestParameters.organizationId, requestParameters.apiMailoutModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a pre reminder email with link to a public version of the invoice where it can be printed or downloaded as a pdf.  The invoice needs to be overdue to send the reminder.  A pre-reminder is a mail reminding the customer, that the invoice is overdue. This will not cause a reminder to be created in Dinero, this is only a mailout.
     * @summary Send invoice prereminder
     * @param {InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v1OrganizationIdInvoicesGuidEmailPreReminderPost(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderPostRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v1OrganizationIdInvoicesGuidEmailPreReminderPost(requestParameters.guid, requestParameters.organizationId, requestParameters.apiMailoutModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the email template for a pre-reminder. This can be used to preview what will be sent out on the email. These standards can be overwritten during the sending phase.
     * @summary Get pre-reminder template
     * @param {InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderTemplateGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v1OrganizationIdInvoicesGuidEmailPreReminderTemplateGet(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidEmailPreReminderTemplateGetRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v1OrganizationIdInvoicesGuidEmailPreReminderTemplateGet(requestParameters.guid, requestParameters.organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate and saves a creditnote draft of a given booked invoice. If you need to create a standalone creditnote or a partial creditnote, please look at the creditnote category further down the documentation. Remeber to also book and send the creditnote to fully automate the booking process.
     * @summary Create credit note from invoice
     * @param {InvoicesApiV1OrganizationIdInvoicesGuidGenerateCreditnotePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v1OrganizationIdInvoicesGuidGenerateCreditnotePost(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidGenerateCreditnotePostRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v1OrganizationIdInvoicesGuidGenerateCreditnotePost(requestParameters.guid, requestParameters.organizationId, requestParameters.timestampObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get invoice as json or pdf.  Define the Accept header of your request to either \'application/json\' or \'application/octet-stream\'.  PDF\'s can only be generated from booked invoices.
     * @summary Get invoice as json or pdf
     * @param {InvoicesApiV1OrganizationIdInvoicesGuidGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v1OrganizationIdInvoicesGuidGet(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidGetRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v1OrganizationIdInvoicesGuidGet(requestParameters.guid, requestParameters.organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the mailouts for a specific invoice.
     * @summary List mailouts
     * @param {InvoicesApiV1OrganizationIdInvoicesGuidMailoutsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v1OrganizationIdInvoicesGuidMailoutsGet(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidMailoutsGetRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v1OrganizationIdInvoicesGuidMailoutsGet(requestParameters.guid, requestParameters.organizationId, requestParameters.changesSince, requestParameters.includeSms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a payment from an invoice. Only booked invoices can have payments.
     * @summary Delete payment from invoice
     * @param {InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPaymentGuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPaymentGuidDeleteRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v1OrganizationIdInvoicesGuidPaymentsPaymentGuidDelete(requestParameters.guid, requestParameters.paymentGuid, requestParameters.organizationId, requestParameters.timestampObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a payment for an invoice. Payments can only be added to a booked invoice.
     * @summary Add payment to invoice
     * @param {InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v1OrganizationIdInvoicesGuidPaymentsPost(requestParameters: InvoicesApiV1OrganizationIdInvoicesGuidPaymentsPostRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v1OrganizationIdInvoicesGuidPaymentsPost(requestParameters.guid, requestParameters.organizationId, requestParameters.paymentCreateModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new draft invoice. This invoice can be found in the \"Salg\" section of Dinero. A draft invoice will not count in the accounts untill booked.  Think about using the book and send endpoints after the draft has been created to further automate the booking process for the user.  Also note that the date on the invoice, should always be the date the invoice is sent to the customer.
     * @summary Create invoice
     * @param {InvoicesApiV1OrganizationIdInvoicesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v1OrganizationIdInvoicesPost(requestParameters: InvoicesApiV1OrganizationIdInvoicesPostRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v1OrganizationIdInvoicesPost(requestParameters.organizationId, requestParameters.invoiceCreateModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get possible templates for invoices, which change the design and look of the invoice. Only possible to customize in Dineros UI.
     * @summary List invoice templates
     * @param {InvoicesApiV1OrganizationIdInvoicesTemplatesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v1OrganizationIdInvoicesTemplatesGet(requestParameters: InvoicesApiV1OrganizationIdInvoicesTemplatesGetRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v1OrganizationIdInvoicesTemplatesGet(requestParameters.organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send an e-invoice to an EAN customer. This is a public system for electronic invoicing.
     * @summary Send invoice with EAN
     * @param {InvoicesApiV2OrganizationIdInvoicesGuidEInvoicePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v2OrganizationIdInvoicesGuidEInvoicePost(requestParameters: InvoicesApiV2OrganizationIdInvoicesGuidEInvoicePostRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v2OrganizationIdInvoicesGuidEInvoicePost(requestParameters.guid, requestParameters.organizationId, requestParameters.eanSendModelV2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the email template for an invoice. This can be used to preview what will be sent out on the email. These standards can be overwritten during the sending phase.
     * @summary Get invoice email template
     * @param {InvoicesApiV2OrganizationIdInvoicesGuidEmailTemplateGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v2OrganizationIdInvoicesGuidEmailTemplateGet(requestParameters: InvoicesApiV2OrganizationIdInvoicesGuidEmailTemplateGetRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v2OrganizationIdInvoicesGuidEmailTemplateGet(requestParameters.guid, requestParameters.organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the payments for an invoice
     * @summary Get payments for invoice
     * @param {InvoicesApiV2OrganizationIdInvoicesGuidPaymentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v2OrganizationIdInvoicesGuidPaymentsGet(requestParameters: InvoicesApiV2OrganizationIdInvoicesGuidPaymentsGetRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v2OrganizationIdInvoicesGuidPaymentsGet(requestParameters.guid, requestParameters.organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send electronic invoice to following destinations: P, SE, EAN/GLN, Danish vat (CVR) -numbers
     * @summary Send electronic invoice
     * @param {InvoicesApiV3OrganizationIdInvoicesGuidEInvoicePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public v3OrganizationIdInvoicesGuidEInvoicePost(requestParameters: InvoicesApiV3OrganizationIdInvoicesGuidEInvoicePostRequest, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).v3OrganizationIdInvoicesGuidEInvoicePost(requestParameters.guid, requestParameters.organizationId, requestParameters.eInvoiceSendModel, options).then((request) => request(this.axios, this.basePath));
    }
}

